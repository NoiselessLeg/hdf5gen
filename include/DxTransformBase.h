#pragma once
#include "DxTransformFactory.h"
#include "H5Cpp.h"

#define HDF5_FIELD_OFFSET(StructVarName, FieldName) \
static_cast<std::size_t>(reinterpret_cast<const char*>(&StructVarName.FieldName) - reinterpret_cast<const char*>(&StructVarName))

namespace DxTransform
{
    template <typename UnderlyingT, typename H5Type>
    class DxTransformBase
    {
    public:
        DxTransformBase() noexcept:
            datatype_id_(sizeof(UnderlyingT))
        {
        }
        
        // all fun write methods here
        
    protected:
        H5Type& h5_datatype()
        {
            return datatype_id;
        }
        
    private:
        H5Type datatype_id_;
    };
    
}
    
    
// would be generated by the code generator
class FooDxTransform : public DxTransform::DxTransformBase<Foo, H5::CompType>
{
public:
    FooDxTransform(DxTransformFactory& parentFac) noexcept:
        DxTransform::DxTransformBase<Foo, H5::CompType>()
    {
        H5::CompType& myType = h5_datatype();
        static constexpr Foo zzz_tmp {};
        
        // for each field of Foo:
        // if it is atomic, get the atomic transform (i.e. the native type)
        // else, ask the parent factory to get the transform for it (or
        // create it)
    }
    
};


// would be generated by the code generatorfor enum types
class FooDxTransform : public DxTransform::DxTransformBase<FooEnum, H5::EnumType>
{
public:
    FooDxTransform() noexcept:
        DxTransform::DxTransformBase<FooEnum, H5::EnumType>()
    {
        H5::EnumType& myType = h5_datatype();
        unsigned int ev {};
        myType.insert("VALUE_1", (ev=123,&ev));
    }
    
private:
};

#undef HDF5_FIELD_OFFSET